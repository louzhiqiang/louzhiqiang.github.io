<!DOCTYPE HTML>
<html lang="zh-Hans">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="hudi探索--读取时如何进行FileSlice, 痒痒 团团 和 咘咘">
    <meta name="description" content="hudi探索–读取时如何进行FileSlice在看hudi的小文件合并的时候，突然对于hudi的读取过程有些模糊，然后重温了一遍，把这块的细节记录一下。
概念FileGrouppartition + fileId = FileGroup
F">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>hudi探索--读取时如何进行FileSlice | 痒痒 团团 和 咘咘</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="痒痒 团团 和 咘咘" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">痒痒 团团 和 咘咘</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">痒痒 团团 和 咘咘</div>
        <div class="logo-desc">
            
            从自律开始
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">hudi探索--读取时如何进行FileSlice</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/hudi/">
                                <span class="chip bg-color">hudi</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-category">
                                大数据
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-06-06
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="hudi探索–读取时如何进行FileSlice"><a href="#hudi探索–读取时如何进行FileSlice" class="headerlink" title="hudi探索–读取时如何进行FileSlice"></a>hudi探索–读取时如何进行FileSlice</h1><p>在看hudi的小文件合并的时候，突然对于hudi的读取过程有些模糊，然后重温了一遍，把这块的细节记录一下。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="FileGroup"><a href="#FileGroup" class="headerlink" title="FileGroup"></a>FileGroup</h3><p>partition + fileId = FileGroup</p>
<h3 id="FileSlice"><a href="#FileSlice" class="headerlink" title="FileSlice"></a>FileSlice</h3><p>一个commit timestamp 就是一个FileSlice</p>
<h3 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h3><p>元数据这部分，是存储在.hoodie下，然后 在fsView的构建，会构建出基于FileGroup的视图。</p>
<h3 id="HoodieTableFileSystemView"><a href="#HoodieTableFileSystemView" class="headerlink" title="HoodieTableFileSystemView"></a>HoodieTableFileSystemView</h3><p>数据构建的视图，这里主要是基于文件系统去获取文件列表，然后基于文件列表，抽取文件名称中的fileId和timestamp，就可以构建FileGroup。</p>
<h2 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h2><p>这里以flink读取hudi数据源为例。</p>
<p>在读取数据的时候，会按照split进行数据的粒度进行读取。而一个split就是一个fileslice。所以这里的问题就转化为 hudi 是如何划分 split 的。</p>
<h3 id="初始化metaClient"><a href="#初始化metaClient" class="headerlink" title="初始化metaClient"></a>初始化metaClient</h3><p>在 HoodieTableSource 中的 初始化的时候，就会构建出一个 metaClient，主要实现类是 HoodieTableMetaClient。</p>
<p><img src="/images/HoodieTableMetaClient_uml.png" alt=""></p>
<p>从他提供的api可以看出，有一个很重要的方法就是 getActiveTimeline()。</p>
<p>他初始化了  HoodieActiveTimeline ，这个类就是时间线的主要实现，他继承了HoodieDefaultTimeline。所有跟timeline相关的操作都是来自于这个类和他的父类。类里边都定义了事务的状态、timestamp的生成等等。</p>
<blockquote>
<p>HoodieActiveTimeline的注释：</p>
<p>Represents the Active Timeline for the Hoodie table. Instants for the last 12 hours (configurable) is in the ActiveTimeline and the rest are Archived. ActiveTimeline is a special timeline that allows for creation of instants on the timeline.</p>
<p>ActiveTimeline中包含最近12小时(可配置)的即时消息，其余的则存档。ActiveTimeline是一个特殊的时间轴，允许在时间轴上创建瞬间。</p>
<p>The timeline is not automatically reloaded on any mutation operation, clients have to manually call reload() so that they can chain multiple mutations to the timeline and then call reload() once.</p>
<p>ActiveTimeline 必须调用reload，才能用到当前最新的数据。</p>
<p>This class can be serialized and de-serialized and on de-serialization the FileSystem is re-initialized.</p>
<p>这个类可以序列化和反序列化，在反序列化时重新初始化文件系统。</p>
</blockquote>
<p>HoodieDefaultTimeline 基于接口 HoodieTimeline 的默认实现。但是基于场景需要不同的timeline的用途，也就有了不同类型的实现。</p>
<p>metaClient初始化的时候会把文件系统的句柄也初始化进去。而这个fileSystemView的创建会初始化 AbstractTableFileSystemView， 会形成一个 globalViewMap ， key是表的基础路径，value就是 AbstractTableFileSystemView。</p>
<p>这个view的创建是在 FileSystemViewManager 进行的，默认创建是 MEMORY 类型的view。这里创建使用的是 HoodieTableFileSystemView 。</p>
<blockquote>
<p>这个视图还有一个类型就是 IncrementalTimelineSyncFileSystemView，视图数据在内存里之后，就不会再次去全量获取，而是可以通过增量的方式。可以按照分区来更新。</p>
</blockquote>
<p>timeline是后续instant的流转的核心逻辑所在。所以在metaClient里会有一个他的实例。</p>
<p>metaClient在初始化的时候，就会把内存化的view初始化完成，并载入。</p>
<p>因为会涉及到具体文件系统里的数据，所以也会有对应的fs入口类的初始化。</p>
<p>在 AbstractTableFileSystemView 的 init方法中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HoodieTableMetaClient metaClient, HoodieTimeline visibleActiveTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metaClient = metaClient;</span><br><span class="line">    refreshTimeline(visibleActiveTimeline);</span><br><span class="line">    resetFileGroupsReplaced(visibleCommitsAndCompactionTimeline);</span><br><span class="line">    <span class="keyword">this</span>.bootstrapIndex =  BootstrapIndex.getBootstrapIndex(metaClient);</span><br><span class="line">    <span class="comment">// Load Pending Compaction Operations</span></span><br><span class="line">    resetPendingCompactionOperations(CompactionUtils.getAllPendingCompactionOperations(metaClient).values().stream()</span><br><span class="line">        .map(e -&gt; Pair.of(e.getKey(), CompactionOperation.convertFromAvroRecordInstance(e.getValue()))));</span><br><span class="line">    resetBootstrapBaseFileMapping(Stream.empty());</span><br><span class="line">    resetFileGroupsInPendingClustering(ClusteringUtils.getAllFileGroupsInPendingClusteringPlans(metaClient));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里会看到很多reset，都是内存里一次载入，文件系统里的存储是都从线上落盘进来的。</p>
<p>HoodieActiveTimeline 的初始化，主要是根据.hoodie目录下的文件来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setInstants(metaClient.scanHoodieInstantsFromFileSystem(includedExtensions, applyLayoutFilters));</span><br></pre></td></tr></table></figure>

<p>这个 scanHoodieInstantsFromFileSystem 就是在遍历.hoodie 目录。把里边的每个文件都根据标识进行划分，他的命名：{timestamp}.{action}.{state}</p>
<p>根据这三个信息就可以生成一个 HoodieInstant 。</p>
<p>生成这样的一个HoodieInstant stream之后，还需要按照layout的实现来进行聚合去重，目前在v1中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;HoodieInstant&gt; <span class="title">filterHoodieInstants</span><span class="params">(Stream&lt;HoodieInstant&gt; instantStream)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instantStream.collect(Collectors.groupingBy(instant -&gt; Pair.of(instant.getTimestamp(),</span><br><span class="line">          HoodieInstant.getComparableAction(instant.getAction())))).values().stream()</span><br><span class="line">          .map(hoodieInstants -&gt; hoodieInstants.stream().reduce((x, y) -&gt; &#123;</span><br><span class="line">            <span class="comment">// Pick the one with the highest state</span></span><br><span class="line">            <span class="keyword">if</span> (x.getState().compareTo(y.getState()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">          &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>同一个timestamp会进行聚合，然后进行比较去重，这里reduce的策略是按照state的大小来比较，因为state本身就是以枚举类型存在，本身底层就是一个整数，所以是可以进行大小比较的，在代码编写的时候，对应的顺序就决定了大小。目前代码里是这个顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">   <span class="comment">// Requested State (valid state for Compaction)</span></span><br><span class="line">   REQUESTED,</span><br><span class="line">   <span class="comment">// Inflight instant</span></span><br><span class="line">   INFLIGHT,</span><br><span class="line">   <span class="comment">// Committed instant</span></span><br><span class="line">   COMPLETED,</span><br><span class="line">   <span class="comment">// Invalid instant</span></span><br><span class="line">   INVALID</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>后续的数据获取都会围绕这个hoodie instant的 stream 进行数据的获取。</p>
<h3 id="FileGroup的形成"><a href="#FileGroup的形成" class="headerlink" title="FileGroup的形成"></a>FileGroup的形成</h3><p>在读取数据的时候（flink这里，主要是通过IncrementalInputSplits获取split），拿到了metaClient，里边包含了 timeline 和 fs，下边一步就是确认数据边界，也就是我们要从数据源获取哪些instant的数据。</p>
<ul>
<li><p>首先reloadActiveTimeline</p>
</li>
<li><p>获取commitTimeline</p>
</li>
<li><p>获取 instants Range：根据上边commitTimeline获取最后一个instant ，然后确认一下开始的instant（如果从state有读取到，那就按照state里的，如果没有读取到，那就按照表设置里的，如果表设置里也没有，那就是从0开始）。</p>
</li>
<li><p>根据 instant range 去获取metadata，组织成 HoodieCommitMetadata 的stream。</p>
<ul>
<li><p>获取需要的instant</p>
</li>
<li><p>根据instant获取metadata，这块的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HoodieCommitMetadata <span class="title">getCommitMetadata</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      HoodieInstant instant,</span></span></span><br><span class="line"><span class="function"><span class="params">      HoodieTimeline timeline)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data = timeline.getInstantDetails(instant).get();</span><br><span class="line">    <span class="keyword">return</span> HoodieCommitMetadata.fromBytes(data, HoodieCommitMetadata<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<pre><code>这里的 getInstantDetails  就是调用的ActiveTimeline初始化的时候的那个detail function。代码如下：</code></pre></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Option&lt;<span class="keyword">byte</span>[]&gt; getInstantDetails(HoodieInstant instant) &#123;</span><br><span class="line">    Path detailPath = <span class="keyword">new</span> Path(metaClient.getMetaPath(), instant.getFileName());</span><br><span class="line">    <span class="keyword">return</span> readDataFromPath(detailPath);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span> Option&lt;<span class="keyword">byte</span>[]&gt; readDataFromPath(Path detailPath) &#123;</span><br><span class="line">    <span class="keyword">try</span> (FSDataInputStream is = metaClient.getFs().open(detailPath)) &#123;</span><br><span class="line">      <span class="keyword">return</span> Option.of(FileIOUtils.readAsByteArray(is));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HoodieIOException(<span class="string">"Could not read commit details from "</span> + detailPath, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>主要实现就是根据instant，也就知道了对应的文件，也就可以拿到里边存储的metadata。</p>
<p>接着上边的获取metadata流程之后，就要获取filestatus。这一步里也要读取getArchivedMetadata ， 在.hoodie目录下的文件，主要是action对应的文件，会根据一定的策略进行归档，比如时间，默认是保留12小时以内的instant，超过12小时以前的都会被归档到 .archived 目录下。getArchivedMetadata会根据instant range进行过滤。</p>
<p>如果归档目录下也有需要的instant metadata，就需要跟已有的instant metadata ，进行merge。merge完之后的 commit meta list就是总的 数据获取的范围。</p>
<blockquote>
<p>根据以上信息获取到的数据，就可以圈定我们需要从哪些文件获取哪些数据</p>
</blockquote>
<p>然后，可以根据这些元数据，拿到分区数据。这里有个小小的优化，就是分区下推，把范围按照分区尽量缩小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.requiredPartitions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        writePartitions = writePartitions.stream()</span><br><span class="line">            .filter(<span class="keyword">this</span>.requiredPartitions::contains).collect(Collectors.toSet());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>表越大，这个优化越管用，而且可以在上游根据数据的分区去并行获取数据，也就可以在获取数据的时候去按照这个下推下去，这样也就效率更高。</p>
<blockquote>
<p>hudi本身的数据是分区不相关的，也就划了个并行的道道。</p>
</blockquote>
<p>然后就是构建 fileStatuses ，这个就是遍历 metadataList 得来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, FileStatus&gt; <span class="title">getFullPathToFileStatus</span><span class="params">(String basePath)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, FileStatus&gt; fullPathToFileStatus = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;HoodieWriteStat&gt; stats : getPartitionToWriteStats().values()) &#123;</span><br><span class="line">      <span class="comment">// Iterate through all the written files.</span></span><br><span class="line">      <span class="keyword">for</span> (HoodieWriteStat stat : stats) &#123;</span><br><span class="line">        String relativeFilePath = stat.getPath();</span><br><span class="line">        Path fullPath = relativeFilePath != <span class="keyword">null</span> ? FSUtils.getPartitionPath(basePath, relativeFilePath) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (fullPath != <span class="keyword">null</span>) &#123;</span><br><span class="line">          FileStatus fileStatus = <span class="keyword">new</span> FileStatus(stat.getFileSizeInBytes(), <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">              <span class="number">0</span>, fullPath);</span><br><span class="line">          fullPathToFileStatus.put(fullPath.getName(), fileStatus);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullPathToFileStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里也比较简单直接一些，FileStatus就是包含了文件大小和路径的一个对象，这个对象是hadoop 包里的。</p>
<p>获取完fileStatus ， 然后就是初始化一个 HoodieTableFileSystemView 的对象。这个对象初始化主要如下：</p>
<ul>
<li><p>createPartitionToFileGroups</p>
</li>
<li><p>addFilesToView 这个方法比较重要，这个是组织文件，形成FileGroup 的视图的主要入口。</p>
</li>
</ul>
<p>下边我们着重分析一下FileGroup的形成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;HoodieFileGroup&gt; <span class="title">addFilesToView</span><span class="params">(FileStatus[] statuses)</span> </span>&#123;</span><br><span class="line">    HoodieTimer timer = <span class="keyword">new</span> HoodieTimer().startTimer();</span><br><span class="line">    List&lt;HoodieFileGroup&gt; fileGroups = buildFileGroups(statuses, visibleCommitsAndCompactionTimeline, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">long</span> fgBuildTimeTakenMs = timer.endTimer();</span><br><span class="line">    timer.startTimer();</span><br><span class="line">    <span class="comment">// Group by partition for efficient updates for both InMemory and DiskBased stuctures.</span></span><br><span class="line">    fileGroups.stream().collect(Collectors.groupingBy(HoodieFileGroup::getPartitionPath)).forEach((partition, value) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isPartitionAvailableInStore(partition)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bootstrapIndex.useIndex()) &#123;</span><br><span class="line">          <span class="keyword">try</span> (BootstrapIndex.IndexReader reader = bootstrapIndex.createReader()) &#123;</span><br><span class="line">            LOG.info(<span class="string">"Bootstrap Index available for partition "</span> + partition);</span><br><span class="line">            List&lt;BootstrapFileMapping&gt; sourceFileMappings =</span><br><span class="line">                reader.getSourceFileMappingForPartition(partition);</span><br><span class="line">            addBootstrapBaseFileMapping(sourceFileMappings.stream()</span><br><span class="line">                .map(s -&gt; <span class="keyword">new</span> BootstrapBaseFileMapping(<span class="keyword">new</span> HoodieFileGroupId(s.getPartitionPath(),</span><br><span class="line">                    s.getFileId()), s.getBootstrapFileStatus())));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        storePartitionView(partition, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> storePartitionsTs = timer.endTimer();</span><br><span class="line">    LOG.info(<span class="string">"addFilesToView: NumFiles="</span> + statuses.length + <span class="string">", NumFileGroups="</span> + fileGroups.size()</span><br><span class="line">        + <span class="string">", FileGroupsCreationTime="</span> + fgBuildTimeTakenMs</span><br><span class="line">        + <span class="string">", StoreTimeTaken="</span> + storePartitionsTs);</span><br><span class="line">    <span class="keyword">return</span> fileGroups;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的主要思路：先根据fileStatus去构建一个List<HoodieFileGroup>，然后按照partitionpath聚合，然后添加到一个 基于 partition到List<fileGroup>的map视图中。</p>
<p>这里的一个关键方法就是 buildFileGroups ，我们看一下他的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;HoodieFileGroup&gt; <span class="title">buildFileGroups</span><span class="params">(Stream&lt;HoodieBaseFile&gt; baseFileStream,</span></span></span><br><span class="line"><span class="function"><span class="params">      Stream&lt;HoodieLogFile&gt; logFileStream, HoodieTimeline timeline, <span class="keyword">boolean</span> addPendingCompactionFileSlice)</span> </span>&#123;</span><br><span class="line">    Map&lt;Pair&lt;String, String&gt;, List&lt;HoodieBaseFile&gt;&gt; baseFiles =</span><br><span class="line">        baseFileStream.collect(Collectors.groupingBy((baseFile) -&gt; &#123;</span><br><span class="line">          String partitionPathStr = getPartitionPathFromFilePath(baseFile.getPath());</span><br><span class="line">          <span class="keyword">return</span> Pair.of(partitionPathStr, baseFile.getFileId());</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    Map&lt;Pair&lt;String, String&gt;, List&lt;HoodieLogFile&gt;&gt; logFiles = logFileStream.collect(Collectors.groupingBy((logFile) -&gt; &#123;</span><br><span class="line">      String partitionPathStr =</span><br><span class="line">          FSUtils.getRelativePartitionPath(<span class="keyword">new</span> Path(metaClient.getBasePath()), logFile.getPath().getParent());</span><br><span class="line">      <span class="keyword">return</span> Pair.of(partitionPathStr, logFile.getFileId());</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    Set&lt;Pair&lt;String, String&gt;&gt; fileIdSet = <span class="keyword">new</span> HashSet&lt;&gt;(baseFiles.keySet());</span><br><span class="line">    fileIdSet.addAll(logFiles.keySet());</span><br><span class="line"></span><br><span class="line">    List&lt;HoodieFileGroup&gt; fileGroups = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fileIdSet.forEach(pair -&gt; &#123;</span><br><span class="line">      String fileId = pair.getValue();</span><br><span class="line">      HoodieFileGroup group = <span class="keyword">new</span> HoodieFileGroup(pair.getKey(), fileId, timeline);</span><br><span class="line">      <span class="keyword">if</span> (baseFiles.containsKey(pair)) &#123;</span><br><span class="line">        baseFiles.get(pair).forEach(group::addBaseFile);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logFiles.containsKey(pair)) &#123;</span><br><span class="line">        logFiles.get(pair).forEach(group::addLogFile);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (addPendingCompactionFileSlice) &#123;</span><br><span class="line">        Option&lt;Pair&lt;String, CompactionOperation&gt;&gt; pendingCompaction =</span><br><span class="line">            getPendingCompactionOperationWithInstant(group.getFileGroupId());</span><br><span class="line">        <span class="keyword">if</span> (pendingCompaction.isPresent()) &#123;</span><br><span class="line">          <span class="comment">// If there is no delta-commit after compaction request, this step would ensure a new file-slice appears</span></span><br><span class="line">          <span class="comment">// so that any new ingestion uses the correct base-instant</span></span><br><span class="line">          group.addNewFileSliceAtInstant(pendingCompaction.get().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fileGroups.add(group);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fileGroups;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>主要步骤如下：</p>
<p>1、先按照partitionpath + fileid 为 key的map，value是List<HoodieBaseFile></p>
<p>2、先按照partitionpath + fileid 为 key的map，value是List<HoodieLogFile></p>
<p>3、整合上边两部分的key，逐个元素生成 HoodieFileGroup，fileGroup的组成主要就是partitionpath  和 fileId，然后看上边两个map的元素，逐个添加到当前新生成的FileGroup里。</p>
<p>4、FileGroup的生成，在往里边添加文件的时候，会形成FileSlice。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBaseFile</span><span class="params">(HoodieBaseFile dataFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileSlices.containsKey(dataFile.getCommitTime())) &#123;</span><br><span class="line">      fileSlices.put(dataFile.getCommitTime(), <span class="keyword">new</span> FileSlice(fileGroupId, dataFile.getCommitTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    fileSlices.get(dataFile.getCommitTime()).setBaseFile(dataFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a new log file into the group.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLogFile</span><span class="params">(HoodieLogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileSlices.containsKey(logFile.getBaseCommitTime())) &#123;</span><br><span class="line">      fileSlices.put(logFile.getBaseCommitTime(), <span class="keyword">new</span> FileSlice(fileGroupId, logFile.getBaseCommitTime()));</span><br><span class="line">    &#125;</span><br><span class="line">    fileSlices.get(logFile.getBaseCommitTime()).addLogFile(logFile);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>FileSlice 的生成是 fileGroupId 和 timestamp。然后添加对应的文件。</p>
<p>以上就完成了FileGroup的初始化。</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MergeOnReadInputSplit&gt; inputSplits = writePartitions.stream()</span><br><span class="line">        .map(relPartitionPath -&gt; fsView.getLatestMergedFileSlicesBeforeOrOn(relPartitionPath, endInstant)</span><br><span class="line">            .map(fileSlice -&gt; &#123;</span><br><span class="line">              Option&lt;List&lt;String&gt;&gt; logPaths = Option.ofNullable(fileSlice.getLogFiles()</span><br><span class="line">                  .sorted(HoodieLogFile.getLogFileComparator())</span><br><span class="line">                  .map(logFile -&gt; logFile.getPath().toString())</span><br><span class="line">                  .collect(Collectors.toList()));</span><br><span class="line">              String basePath = fileSlice.getBaseFile().map(BaseFile::getPath).orElse(<span class="keyword">null</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> MergeOnReadInputSplit(cnt.getAndAdd(<span class="number">1</span>),</span><br><span class="line">                  basePath, logPaths, endInstant,</span><br><span class="line">                  metaClient.getBasePath(), maxCompactionMemoryInBytes, mergeType, instantRange);</span><br><span class="line">            &#125;).collect(Collectors.toList()))</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这是flink中读取hudi数据划分split的核心部分。</p>
<p>主要思路就是按照分区去遍历，然后在每个分区下，获取fileSlice，构建一个MergeOnReadInputSplit。</p>
<p>getLatestMergedFileSlicesBeforeOrOn 方法 会规整每个FileGroup下的FileSlice，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;FileSlice&gt; <span class="title">getLatestMergedFileSlicesBeforeOrOn</span><span class="params">(String partitionStr, String maxInstantTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      readLock.lock();</span><br><span class="line">      String partition = formatPartitionKey(partitionStr);</span><br><span class="line">      ensurePartitionLoadedCorrectly(partition);</span><br><span class="line">      <span class="keyword">return</span> fetchAllStoredFileGroups(partition)</span><br><span class="line">          .filter(fg -&gt; !isFileGroupReplacedBeforeOrOn(fg.getFileGroupId(), maxInstantTime))</span><br><span class="line">          .map(fileGroup -&gt; &#123;</span><br><span class="line">            Option&lt;FileSlice&gt; fileSlice = fileGroup.getLatestFileSliceBeforeOrOn(maxInstantTime);</span><br><span class="line">            <span class="comment">// if the file-group is under construction, pick the latest before compaction instant time.</span></span><br><span class="line">            <span class="keyword">if</span> (fileSlice.isPresent()) &#123;</span><br><span class="line">              fileSlice = Option.of(fetchMergedFileSlice(fileGroup, fileSlice.get()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fileSlice;</span><br><span class="line">          &#125;).filter(Option::isPresent).map(Option::get).map(<span class="keyword">this</span>::addBootstrapBaseFileIfPresent);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>getLatestFileSliceBeforeOrOn 方法会返回他下边的所有的flieSlice的第一个。</p>
<p>因为元素本身就是排序的，是按照时间倒序的，所以默认就取了最新timestamp的数据。</p>
<p>一个 MergeOnReadInputSplit 数据就是一个FileSlice的数据。</p>
<p>在往外输出的时候，是通过 mergeOnReadInputFormat 进行读取的。在 mergeOnReadInputFormat 的 open 方法里会初始化一个iterator，所有数据的获取模式都是依赖于这种方式。只是不同的视图或者不同的合并方式，需要不同的iterator。</p>
<p>比如 我这里的测试过程，文件是没有parquet文件的，也就是基本都是log文件，这种情况就会走 LogFileOnlyIterator，如果是既有base 也有log文件的话，就会走 MergeIterator。当然还有其他的迭代类型。</p>
<blockquote>
<p>只有log文件的情形：LogFileOnlyIterator返回数据的时候是不过滤的，log文件中有多少，就直接返回所有数据。</p>
<p>base文件和log文件都存在的情况：MergeIterator 就会根据传入的instantRange对数据进行过滤。但是，这个前提也是他已经把数据按照合并条件进行了整合成一条数据了，然后按照数据里的commit_time 进行比较过滤。</p>
<p>只有base文件的情况：BaseFileOnlyFilteringIterator 会根据 instantRange进行过滤。</p>
<p>还有一种情况就是表的配置 hoodie.datasource.merge.type 是 skip_merge 情况，表示实时数据不合并，但是获取两个文件的数据。read the base file records plus the log file records;用的iterator是 SkipMergeIterator。先读取base文件，再读取log文件。</p>
</blockquote>
<p>这里复习一下 MergeIterator 的数据合并。先去读base文件，如果没有在instantRange里的记录，就继续循环。初始的时候，在base文件里肯定有数据，在log文件里不一定有，这个时候就直接返回base文件里的数据。如果在log文件里有，就直接返回log文件里的数据，然后把这个key放入keyToSkip。然后如果base文件循环完了，这时候，可以去遍历log文件，然后设置readlogs 为true，这样下次遍历的时候也会直接去日志了。在读取log的时候，recordKey必须不能在keyToSkip里，因为之前已经发送出去了。然后符合条件的数据会根据元数据转化一下，就直接发送给下游了。</p>
<p>这块的设计可以多看看几回合，会理解的更加深刻。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">zhiqiang.lou</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/louzhiqiang/louzhiqiang.github.io.git/2022/06/06/hudi%E6%8E%A2%E7%B4%A2-%E8%AF%BB%E5%8F%96%E6%97%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CFileSlice/">https://github.com/louzhiqiang/louzhiqiang.github.io.git/2022/06/06/hudi%E6%8E%A2%E7%B4%A2-%E8%AF%BB%E5%8F%96%E6%97%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CFileSlice/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">zhiqiang.lou</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/hudi/">
                                    <span class="chip bg-color">hudi</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2022/06/06/flink%E5%8E%9F%E7%90%86-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="flink原理--内存管理">
                        
                        <span class="card-title">flink原理--内存管理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-06-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-category">
                                    大数据
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/flink/">
                        <span class="chip bg-color">flink</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/06/02/flink%E5%8E%9F%E7%90%86-flink-cdc%E9%87%8D%E8%A6%81%E7%89%88%E6%9C%AC%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="flink原理--flink-cdc重要版本的重要特性">
                        
                        <span class="card-title">flink原理--flink-cdc重要版本的重要特性</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-06-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" class="post-category">
                                    大数据
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/flink/">
                        <span class="chip bg-color">flink</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">zhiqiang.lou</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
