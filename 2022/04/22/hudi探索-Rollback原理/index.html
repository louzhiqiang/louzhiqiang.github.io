<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="hudi," />










<meta name="description" content="hudi探索–Rollback原理场景按照事务的逻辑，当某次commit执行失败的时候，会进行回滚。而回滚的成本其实比较高，这里也就涉及回滚的具体操作以及回滚涉及的影响范围。所以下边就从围绕回滚的操作来看hudi的事务原理。  事务中回滚的操作执行和事务本身的执行是一样重要的。  代码逻辑在0.10.0的代码里，HoodieWriteClient的rollback方法，已经标记为Deprecate">
<meta property="og:type" content="article">
<meta property="og:title" content="hudi探索--Rollback原理">
<meta property="og:url" content="https://github.com/louzhiqiang/louzhiqiang.github.io.git/2022/04/22/hudi%E6%8E%A2%E7%B4%A2-Rollback%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="痒痒 团团 和 咘咘">
<meta property="og:description" content="hudi探索–Rollback原理场景按照事务的逻辑，当某次commit执行失败的时候，会进行回滚。而回滚的成本其实比较高，这里也就涉及回滚的具体操作以及回滚涉及的影响范围。所以下边就从围绕回滚的操作来看hudi的事务原理。  事务中回滚的操作执行和事务本身的执行是一样重要的。  代码逻辑在0.10.0的代码里，HoodieWriteClient的rollback方法，已经标记为Deprecate">
<meta property="og:image" content="https://github.com/images/MergeOnReadRollbackActionExecutor.png">
<meta property="article:published_time" content="2022-04-22T03:01:04.000Z">
<meta property="article:modified_time" content="2022-05-13T03:49:18.000Z">
<meta property="article:author" content="zhiqiang.lou">
<meta property="article:tag" content="hudi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/images/MergeOnReadRollbackActionExecutor.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/louzhiqiang/louzhiqiang.github.io.git/2022/04/22/hudi探索-Rollback原理/"/>





  <title>hudi探索--Rollback原理 | 痒痒 团团 和 咘咘</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">痒痒 团团 和 咘咘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/louzhiqiang/louzhiqiang.github.io.git/2022/04/22/hudi%E6%8E%A2%E7%B4%A2-Rollback%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhiqiang.lou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="痒痒 团团 和 咘咘">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">hudi探索--Rollback原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-22T11:01:04+08:00">
                2022-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="hudi探索–Rollback原理"><a href="#hudi探索–Rollback原理" class="headerlink" title="hudi探索–Rollback原理"></a>hudi探索–Rollback原理</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>按照事务的逻辑，当某次commit执行失败的时候，会进行回滚。而回滚的成本其实比较高，这里也就涉及回滚的具体操作以及回滚涉及的影响范围。所以下边就从围绕回滚的操作来看hudi的事务原理。</p>
<blockquote>
<p>事务中回滚的操作执行和事务本身的执行是一样重要的。</p>
</blockquote>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><p>在0.10.0的代码里，HoodieWriteClient的rollback方法，已经标记为Deprecated，新的代码入口是在 restoreToInstant(instant) 方法里。可见回滚的主要方式就是最新的提交instant要变到 指定的instant，也就是把很多操作变得统一，概念也围绕着instant来进行。这样在代码逻辑的维护性上就更加模块化。</p>
<p>restoreToInstant 方法在执行之前，需要停止对表的写入和compact操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HoodieRestoreMetadata <span class="title">restoreToInstant</span><span class="params">(<span class="keyword">final</span> String instantTime)</span> <span class="keyword">throws</span> HoodieRestoreException </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"Begin restore to instant "</span> + instantTime);</span><br><span class="line">    <span class="keyword">final</span> String restoreInstantTime = HoodieActiveTimeline.createNewInstantTime();</span><br><span class="line">    Timer.Context timerContext = metrics.getRollbackCtx();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HoodieTable&lt;T, I, K, O&gt; table = createTable(config, hadoopConf, config.isMetadataTableEnabled());</span><br><span class="line">      HoodieRestoreMetadata restoreMetadata = table.restore(context, restoreInstantTime, instantTime);</span><br><span class="line">      <span class="keyword">if</span> (timerContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> durationInMs = metrics.getDurationInMs(timerContext.stop());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalFilesDeleted = restoreMetadata.getHoodieRestoreMetadata().values().stream()</span><br><span class="line">            .flatMap(Collection::stream)</span><br><span class="line">            .mapToLong(HoodieRollbackMetadata::getTotalFilesDeleted)</span><br><span class="line">            .sum();</span><br><span class="line">        metrics.updateRollbackMetrics(durationInMs, totalFilesDeleted);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> restoreMetadata;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HoodieRestoreException(<span class="string">"Failed to restore to "</span> + instantTime, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>回滚逻辑里主要是两个操作，一个是metrics数据的一致性，一个是数据文件本身需要删除的。这里主要是一次事务操作写入也涉及两部分，一个是文件数写入，一个就是metrics的更新。</p>
<p>这里还有一个点就是table的创建，根据不同的引擎操作有不同的实现，然后restore也是接口里的一个实现。</p>
<p>在flink的mor实现里，table的主要实现是 HoodieFlinkMergeOnReadTable ，但是在0.10.0的代码里，还是没有restore的实现。而是rollback的实现，所以目前看这个版本里，flink的rollback实现还是通过rollback方法。</p>
<h4 id="rollback如何触发的"><a href="#rollback如何触发的" class="headerlink" title="rollback如何触发的"></a>rollback如何触发的</h4><p>在hudi的failWrite里，有两个策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performs cleaning of failed writes inline every write operation</span></span><br><span class="line">  EAGER,</span><br><span class="line">  <span class="comment">// performs cleaning of failed writes lazily during clean</span></span><br><span class="line">  LAZY,</span><br><span class="line">  <span class="comment">// Does not clean failed writes</span></span><br><span class="line">  NEVER;</span><br></pre></td></tr></table></figure>

<p>如果是第一个，就代表写入失败的回滚会在每次写操作触发的时候就直接进行。反之，就是第二个策略，会在clean的时候进行rollback的执行。而第三个就是不清理。一般会选择第二个。如果业务逻辑不是很复杂也不担心延迟等问题，倒是可以选择前者。不过在clean的时候去处理rollback的执行，也是优化执行方式之一。</p>
<p>在clean策略里，会触发关于rollback的执行。主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),</span><br><span class="line">        HoodieTimeline.CLEAN_ACTION, () -&gt; rollbackFailedWrites(skipLocking));</span><br></pre></td></tr></table></figure>

<p>所以如果策略是lazy的话，那么就会执行这个方法中的第三个参数，也就是那个function。</p>
<h4 id="rollback的主业务逻辑"><a href="#rollback的主业务逻辑" class="headerlink" title="rollback的主业务逻辑"></a>rollback的主业务逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Rollback all failed writes.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> skipLocking if this is triggered by another parent transaction, locking can be skipped.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">rollbackFailedWrites</span><span class="params">(<span class="keyword">boolean</span> skipLocking)</span> </span>&#123;</span><br><span class="line">    HoodieTable&lt;T, I, K, O&gt; table = createTable(config, hadoopConf);</span><br><span class="line">    List&lt;String&gt; instantsToRollback = getInstantsToRollback(table.getMetaClient(), config.getFailedWritesCleanPolicy(), Option.empty());</span><br><span class="line">    Map&lt;String, Option&lt;HoodiePendingRollbackInfo&gt;&gt; pendingRollbacks = getPendingRollbackInfos(table.getMetaClient());</span><br><span class="line">    instantsToRollback.forEach(entry -&gt; pendingRollbacks.putIfAbsent(entry, Option.empty()));</span><br><span class="line">    rollbackFailedWrites(pendingRollbacks, skipLocking);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>获取table。这一步在flink里就是HoodieFlinkMergeOnReadTable。</p>
</li>
<li><p>获取需要回滚的instant。获取inflight状态的instant，过滤出处于超时状态的instant操作，这一部分就是需要回滚的。</p>
</li>
<li><p>获取rollbackplan。获取ROLLBACK_ACTION的instant，且状态是未完成的。然后返回一个instant timestamp 和 HoodiePendingRollbackInfo 的Pair对象。</p>
</li>
<li><p>整合所有需要执行的回滚。以pendingRollbacks为主体。</p>
</li>
<li><p>回滚操作。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rollbackFailedWrites</span><span class="params">(Map&lt;String, Option&lt;HoodiePendingRollbackInfo&gt;&gt; instantsToRollback, <span class="keyword">boolean</span> skipLocking)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sort in reverse order of commit times</span></span><br><span class="line">    LinkedHashMap&lt;String, Option&lt;HoodiePendingRollbackInfo&gt;&gt; reverseSortedRollbackInstants = instantsToRollback.entrySet()</span><br><span class="line">        .stream().sorted((i1, i2) -&gt; i2.getKey().compareTo(i1.getKey()))</span><br><span class="line">        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1, LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Option&lt;HoodiePendingRollbackInfo&gt;&gt; entry : reverseSortedRollbackInstants.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (HoodieTimeline.compareTimestamps(entry.getKey(), HoodieTimeline.LESSER_THAN_OR_EQUALS,</span><br><span class="line">          HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) &#123;</span><br><span class="line">        <span class="comment">// do we need to handle failed rollback of a bootstrap</span></span><br><span class="line">        rollbackFailedBootstrap();</span><br><span class="line">        HeartbeatUtils.deleteHeartbeatFile(fs, basePath, entry.getKey(), config);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rollback(entry.getKey(), entry.getValue(), skipLocking);</span><br><span class="line">        HeartbeatUtils.deleteHeartbeatFile(fs, basePath, entry.getKey(), config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先对于instant进行倒序，如果最大的instant都比 FULL_BOOTSTRAP_INSTANT_TS 要小，那么执行完一次就可以直接退出了。</p>
<blockquote>
<p>FULL_BOOTSTRAP_INSTANT_TS 是hudi的hard instant。是分区和表的导入instant。</p>
<p>METADATA_BOOTSTRAP_INSTANT_TS 也是，主要是 表和分区的元数据导入instant。</p>
<p>INIT_INSTANT_TS 是hudi的默认的表创建的初始化的一个instant。</p>
</blockquote>
<p>那么正常执行数据的回滚就是else部分的代码。主要是两个步骤。一是回滚，二是删除心跳文件。</p>
<blockquote>
<p>心跳文件是 .heartbeat 目录下的文件。</p>
</blockquote>
<p>下边来看一下上边rollback方法的主逻辑。</p>
<p>这个rollback就是上边开头提到的rollback方法，在AbstractHoodieWriteClient类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Deprecated</span></span></span><br><span class="line"><span class="comment">   * Rollback the inflight record changes with the given commit time. This</span></span><br><span class="line"><span class="comment">   * will be removed in future in favor of &#123;<span class="doctag">@link</span> AbstractHoodieWriteClient#restoreToInstant(String)&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> commitInstantTime Instant time of the commit</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pendingRollbackInfo pending rollback instant and plan if rollback failed from previous attempt.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> skipLocking if this is triggered by another parent transaction, locking can be skipped.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> HoodieRollbackException if rollback cannot be performed successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollback</span><span class="params">(<span class="keyword">final</span> String commitInstantTime, Option&lt;HoodiePendingRollbackInfo&gt; pendingRollbackInfo, <span class="keyword">boolean</span> skipLocking)</span> <span class="keyword">throws</span> HoodieRollbackException </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"Begin rollback of instant "</span> + commitInstantTime);</span><br><span class="line">    <span class="keyword">final</span> String rollbackInstantTime = pendingRollbackInfo.map(entry -&gt; entry.getRollbackInstant().getTimestamp()).orElse(HoodieActiveTimeline.createNewInstantTime());</span><br><span class="line">    <span class="keyword">final</span> Timer.Context timerContext = <span class="keyword">this</span>.metrics.getRollbackCtx();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      HoodieTable&lt;T, I, K, O&gt; table = createTable(config, hadoopConf);</span><br><span class="line">      Option&lt;HoodieInstant&gt; commitInstantOpt = Option.fromJavaOptional(table.getActiveTimeline().getCommitsTimeline().getInstants()</span><br><span class="line">          .filter(instant -&gt; HoodieActiveTimeline.EQUALS.test(instant.getTimestamp(), commitInstantTime))</span><br><span class="line">          .findFirst());</span><br><span class="line">      <span class="keyword">if</span> (commitInstantOpt.isPresent()) &#123;</span><br><span class="line">        LOG.info(<span class="string">"Scheduling Rollback at instant time :"</span> + rollbackInstantTime);</span><br><span class="line">        Option&lt;HoodieRollbackPlan&gt; rollbackPlanOption = pendingRollbackInfo.map(entry -&gt; Option.of(entry.getRollbackPlan())).orElse(table.scheduleRollback(context, rollbackInstantTime,</span><br><span class="line">            commitInstantOpt.get(), <span class="keyword">false</span>, config.shouldRollbackUsingMarkers()));</span><br><span class="line">        <span class="keyword">if</span> (rollbackPlanOption.isPresent()) &#123;</span><br><span class="line">          <span class="comment">// execute rollback</span></span><br><span class="line">          HoodieRollbackMetadata rollbackMetadata = table.rollback(context, rollbackInstantTime, commitInstantOpt.get(), <span class="keyword">true</span>,</span><br><span class="line">              skipLocking);</span><br><span class="line">          <span class="keyword">if</span> (timerContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> durationInMs = metrics.getDurationInMs(timerContext.stop());</span><br><span class="line">            metrics.updateRollbackMetrics(durationInMs, rollbackMetadata.getTotalFilesDeleted());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> HoodieRollbackException(<span class="string">"Failed to rollback "</span> + config.getBasePath() + <span class="string">" commits "</span> + commitInstantTime);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">"Cannot find instant "</span> + commitInstantTime + <span class="string">" in the timeline, for rollback"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HoodieRollbackException(<span class="string">"Failed to rollback "</span> + config.getBasePath() + <span class="string">" commits "</span> + commitInstantTime, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要是整合HoodieRollbackPlan。首先是rollback执行需要的instant。然后是确认需要回滚的instant。然后是确认HoodieRollbackPlan的存在。</p>
<p>HoodieRollbackPlan 如果不存在会调用 table 对应的 scheduleRollback 方法进行生成。如果存在就直接用table的rollback方法进行执行。</p>
<p>这俩方法我们在每一个table类型的实现里都会注意到。</p>
<p>我们可以看一下HoodieFlinkMergeonReadTable里的实现，看一下如何生成计划，如何执行的。</p>
<h5 id="plan的生成"><a href="#plan的生成" class="headerlink" title="plan的生成"></a>plan的生成</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Option&lt;HoodieRollbackPlan&gt; <span class="title">scheduleRollback</span><span class="params">(HoodieEngineContext context, String instantTime, HoodieInstant instantToRollback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">boolean</span> skipTimelinePublish, <span class="keyword">boolean</span> shouldRollbackUsingMarkers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BaseRollbackPlanActionExecutor(context, config, <span class="keyword">this</span>, instantTime, instantToRollback, skipTimelinePublish,</span><br><span class="line">        shouldRollbackUsingMarkers).execute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HoodieRollbackMetadata <span class="title">rollback</span><span class="params">(HoodieEngineContext context, String rollbackInstantTime, HoodieInstant commitInstant,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">boolean</span> deleteInstants, <span class="keyword">boolean</span> skipLocking)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MergeOnReadRollbackActionExecutor(context, config, <span class="keyword">this</span>, rollbackInstantTime, commitInstant, deleteInstants,</span><br><span class="line">        skipLocking).execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>scheduleRollback 的实现主要是 BaseRollbackPlanActionExecutor 实现的，</p>
<p>在execute方法中，主要就是根据instantToRollback生成回滚计划。然后写入timeline，这样就可以调度执行了。生成计划主要是根据不同的执行操作来确认怎么执行回滚。</p>
<p>这个逻辑在RollbackUtils的 generateRollbackRequestsUsingFileListingMOR 方法里。不同的表类型和不同的执行引擎，这个计划是会有差异的，因为它们涉及的环境以及执行操作都是不一样的，自然回滚需要恢复的点也是不一样的。</p>
<p>我们稍微捋一下这块的逻辑，对于hudi的事务机制会有一定的深入理解。</p>
<blockquote>
<p>rollback的plan生成的时候，涉及载体是基于marker file还是内存的list来生成。配置是  hoodie.rollback.using.markers  ，默认是：true。 注释：Enables a more efficient mechanism for rollbacks based on the marker files generated during the writes. Turned on by default.</p>
</blockquote>
<p>在上边schudle中，一个关键逻辑就是 用当前配置中定制的类来生成plan。这里主要用到的就是 MarkerBasedRollbackStrategy 这个类。</p>
<p>在 MarkerBasedRollbackStrategy 中会调用 getRollbackRequests 获取rollback的的request，这个方法会根据marker下的文件类型，来生成不同的request。这个的文件类型是根据生成当前这个instant的commit类型。这里常见的类型是Append，那么会调用 getRollbackRequestForAppend来生成HoodieRollbackRequest。</p>
<p>HoodieRollbackRequest 是一次rollback的元数据对象，主要包含 分区路径、文件id、baseCommitTime、需要清理的文件，stats需要的变更。</p>
<p>如果是 MERGE 或者 CREATE 类型的文件，那么就会直接清理掉文件了。</p>
<p>这里贴一下这块逻辑的代码，标注一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;HoodieRollbackRequest&gt; <span class="title">getRollbackRequests</span><span class="params">(HoodieInstant instantToRollback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;String&gt; markerPaths = MarkerBasedRollbackUtils.getAllMarkerPaths(</span><br><span class="line">          table, context, instantToRollback.getTimestamp(), config.getRollbackParallelism());</span><br><span class="line">      <span class="keyword">int</span> parallelism = Math.max(Math.min(markerPaths.size(), config.getRollbackParallelism()), <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> context.map(markerPaths, markerFilePath -&gt; &#123;</span><br><span class="line">        String typeStr = markerFilePath.substring(markerFilePath.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">        IOType type = IOType.valueOf(typeStr);</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">          <span class="keyword">case</span> MERGE:</span><br><span class="line">          <span class="keyword">case</span> CREATE:</span><br><span class="line">            String fileToDelete = WriteMarkers.stripMarkerSuffix(markerFilePath);</span><br><span class="line">            Path fullDeletePath = <span class="keyword">new</span> Path(basePath, fileToDelete);</span><br><span class="line">            String partitionPath = FSUtils.getRelativePartitionPath(<span class="keyword">new</span> Path(basePath), fullDeletePath.getParent());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoodieRollbackRequest(partitionPath, EMPTY_STRING, EMPTY_STRING,</span><br><span class="line">                Collections.singletonList(fullDeletePath.toString()),</span><br><span class="line">                Collections.emptyMap());</span><br><span class="line">          <span class="keyword">case</span> APPEND:</span><br><span class="line">            <span class="keyword">return</span> getRollbackRequestForAppend(WriteMarkers.stripMarkerSuffix(markerFilePath));</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HoodieRollbackException(<span class="string">"Unknown marker type, during rollback of "</span> + instantToRollback);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, parallelism).stream().collect(Collectors.toList());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> HoodieRollbackException(<span class="string">"Error rolling back using marker files written for "</span> + instantToRollback, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> HoodieRollbackRequest <span class="title">getRollbackRequestForAppend</span><span class="params">(String appendBaseFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path baseFilePathForAppend = <span class="keyword">new</span> Path(basePath, appendBaseFilePath);</span><br><span class="line">    String fileId = FSUtils.getFileIdFromFilePath(baseFilePathForAppend);</span><br><span class="line">    String baseCommitTime = FSUtils.getCommitTime(baseFilePathForAppend.getName());</span><br><span class="line">    String partitionPath = FSUtils.getRelativePartitionPath(<span class="keyword">new</span> Path(basePath), <span class="keyword">new</span> Path(basePath, appendBaseFilePath).getParent());</span><br><span class="line">    Map&lt;FileStatus, Long&gt; writtenLogFileSizeMap = getWrittenLogFileSizeMap(partitionPath, baseCommitTime, fileId);</span><br><span class="line">    Map&lt;String, Long&gt; writtenLogFileStrSizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;FileStatus, Long&gt; entry : writtenLogFileSizeMap.entrySet()) &#123;</span><br><span class="line">      writtenLogFileStrSizeMap.put(entry.getKey().getPath().toString(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HoodieRollbackRequest(partitionPath, fileId, baseCommitTime, Collections.emptyList(), writtenLogFileStrSizeMap);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>生成了上边的rollbackRequest，然后就初始化了HoodieRollbackPlan，这个plan就直接进行序列化存储了。</p>
<h5 id="plan的执行"><a href="#plan的执行" class="headerlink" title="plan的执行"></a>plan的执行</h5><p>下边看一下rollback的执行：</p>
<p>执行的代码主要是在 MergeOnReadRollbackActionExecutor 中，主要方法也是 execute 方法。</p>
<p>执行具体的plan的时候，hudi区分了mor表和cow表的执行。</p>
<p><img src="/images/MergeOnReadRollbackActionExecutor.png" alt=""></p>
<p>两种执行的类都是继承BaseRollBack，主要执行方法就是executeRollback()方法。</p>
<p>看一下Base里的executeRollback方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;HoodieRollbackStat&gt; <span class="title">executeRollback</span><span class="params">(HoodieInstant instantToRollback, HoodieRollbackPlan rollbackPlan)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> BaseRollbackHelper(table.getMetaClient(), config).performRollback(context, instantToRollback, rollbackPlan.getRollbackRequests());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>performRollback的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Performs all rollback actions that we have collected in parallel.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;HoodieRollbackStat&gt; <span class="title">performRollback</span><span class="params">(HoodieEngineContext context, HoodieInstant instantToRollback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  List&lt;HoodieRollbackRequest&gt; rollbackRequests)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = Math.max(Math.min(rollbackRequests.size(), config.getRollbackParallelism()), <span class="number">1</span>);</span><br><span class="line">    context.setJobStatus(<span class="keyword">this</span>.getClass().getSimpleName(), <span class="string">"Perform rollback actions"</span>);</span><br><span class="line">    <span class="comment">// If not for conversion to HoodieRollbackInternalRequests, code fails. Using avro model (HoodieRollbackRequest) within spark.parallelize</span></span><br><span class="line">    <span class="comment">// is failing with com.esotericsoftware.kryo.KryoException</span></span><br><span class="line">    <span class="comment">// stack trace: https://gist.github.com/nsivabalan/b6359e7d5038484f8043506c8bc9e1c8</span></span><br><span class="line">    <span class="comment">// related stack overflow post: https://issues.apache.org/jira/browse/SPARK-3601. Avro deserializes list as GenericData.Array.</span></span><br><span class="line">    List&lt;SerializableHoodieRollbackRequest&gt; serializableRequests = rollbackRequests.stream().map(SerializableHoodieRollbackRequest::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> context.reduceByKey(maybeDeleteAndCollectStats(context, instantToRollback, serializableRequests, <span class="keyword">true</span>, parallelism),</span><br><span class="line">        RollbackUtils::mergeRollbackStat, parallelism);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里追到主要的方法是 maybeDeleteAndCollectStats，进去看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">context.flatMap(rollbackRequests, (SerializableFunction&lt;SerializableHoodieRollbackRequest, Stream&lt;Pair&lt;String, HoodieRollbackStat&gt;&gt;&gt;) rollbackRequest -&gt; &#123;</span><br><span class="line">      List&lt;String&gt; filesToBeDeleted = rollbackRequest.getFilesToBeDeleted();</span><br><span class="line">      <span class="keyword">if</span> (!filesToBeDeleted.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 删除文件</span></span><br><span class="line">          <span class="comment">// 按照分区返回stats</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!rollbackRequest.getLogBlocksToBeDeleted().isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 这种情况属于 需要删除某一个logblock，也就是删除一部分文件</span></span><br><span class="line">          <span class="comment">// 这里返回是path 到 文件大小的map</span></span><br><span class="line">          Map&lt;String, Long&gt; logFilesToBeDeleted = rollbackRequest.getLogBlocksToBeDeleted();</span><br><span class="line">          String fileId = rollbackRequest.getFileId();</span><br><span class="line">          String latestBaseInstant = rollbackRequest.getLatestBaseInstant();</span><br><span class="line">          。。。</span><br><span class="line">          <span class="comment">// generate metadata</span></span><br><span class="line">          <span class="keyword">if</span> (doDelete) &#123;</span><br><span class="line">            Map&lt;HoodieLogBlock.HeaderMetadataType, String&gt; header = generateHeader(instantToRollback.getTimestamp());</span><br><span class="line">            <span class="comment">// if update belongs to an existing log file</span></span><br><span class="line">            <span class="comment">// HoodieCommandBlock 是 一个专用用来回滚的block。</span></span><br><span class="line">            <span class="comment">// 注释：Command block issues a specific command to the scanner.</span></span><br><span class="line">            writer.appendBlock(<span class="keyword">new</span> HoodieCommandBlock(header));</span><br><span class="line">            。。。</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个针对logblock的回滚操作简单直接，就是插入了一个特殊类型的logBlock，但是里边没啥数据，就是指定了某个commit失效。在读取数据的时候，通过scanner进行了整合。这属于读放大的代价解决回滚的写放大。</p>
</blockquote>
<p>稍后要去读取的scanner里，看看如何进行的整合。</p>
<blockquote>
<p>在读取的时候不去读取他前一个block块的数据。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>rollback跟写入操作是同样重要的，因为提供了事务语义，那么为了支持一定语义的事务完整性，回滚也必须是正确的，否则就破坏了数据一致性。</p>
<p>hudi支持表类型有两种，支持的计算引擎目前有三种，flink、spark 以及 java操作，rollback同样也是针对三者有自己的实现。鉴于三个引擎的复杂度完全不一样，failover的机制也不一样，那么回滚涉及的操作也是不一样的。所以这块还要具体问题具体分析，不过基本原理有一定的相通性，所以在思考这部分的时候，相信hudi也在尽量保持一致的设计，减小模块和引擎的耦合，通过层次设计来减小不同引擎的融合代价。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hudi/" rel="tag"># hudi</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/18/hudi%E6%8E%A2%E7%B4%A2-clean%E5%8E%9F%E7%90%86/" rel="next" title="hudi探索--clean原理">
                <i class="fa fa-chevron-left"></i> hudi探索--clean原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/05/05/flink%E5%8E%9F%E7%90%86-streamGraph%E7%9A%84%E7%94%9F%E6%88%90/" rel="prev" title="flink原理--streamGraph的生成">
                flink原理--streamGraph的生成 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhiqiang.lou</p>
              <p class="site-description motion-element" itemprop="description">从自律开始</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">154</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#hudi探索–Rollback原理"><span class="nav-number">1.</span> <span class="nav-text">hudi探索–Rollback原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#场景"><span class="nav-number">1.1.</span> <span class="nav-text">场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码逻辑"><span class="nav-number">1.2.</span> <span class="nav-text">代码逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rollback如何触发的"><span class="nav-number">1.2.1.</span> <span class="nav-text">rollback如何触发的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rollback的主业务逻辑"><span class="nav-number">1.2.2.</span> <span class="nav-text">rollback的主业务逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#plan的生成"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">plan的生成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#plan的执行"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">plan的执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhiqiang.lou</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
